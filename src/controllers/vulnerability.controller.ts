import { isDocumentArray } from "@typegoose/typegoose";
import { Request, Response } from "express";
import {
  ChangeHistoryModel,
  ProjectModel,
  ResolutionHistoryModel,
  TicketModel,
} from "../models/models";
import { errorResponse, successResponse } from "../utils/responseFormat";
import { fetchVulnsFromNVD } from "../utils/vuln";

export async function getResolveProgress(req: Request, res: Response) {
  const { projectName } = req.query;
  try {
    const tickets = await TicketModel.find({
      projectName,
    });
    const resolvedTickets = tickets.filter(
      (ticket) => ticket.status === "closed"
    );
    // Count number of resolved tickets
    let count = 0;
    resolvedTickets.forEach(
      (ticket) => (count += ticket.targetedVulnerability.length)
    );
    const project = await ProjectModel.findOne({ name: projectName }).populate({
      path: "phaseList",
      populate: {
        path: "artifacts",
      },
    });
    if (!project) {
      return res.json(errorResponse("Project does not exist"));
    }
    let total = 0;
    if (isDocumentArray(project.phaseList)) {
      project.phaseList.forEach((phase) => {
        if (isDocumentArray(phase.artifacts)) {
          phase.artifacts.forEach((artifact) => {
            total += artifact?.vulnerabilityList
              ? artifact.vulnerabilityList.length
              : 0;
          });
        }
      });
    }
    const response = {
      total,
      resolved: count,
    };
    return res.json(successResponse(response, "Progress fetched successfully"));
  } catch (error) {
    return res.json(errorResponse(`Internal server error: ${error}`));
  }
}
export async function addResolution(req: Request, res: Response) {
  const { data } = req.body;
  try {
    const resolution = await ResolutionHistoryModel.findOne({
      cveId: data.cveId,
    });
    if (!resolution) {
      await ResolutionHistoryModel.create({
        cveId: data.cveId,
        resolution: [
          {
            createdBy: req.user?.username,
            description: data.description,
          },
        ],
      });
    } else {
      await ResolutionHistoryModel.updateOne(
        { cveId: data.cveId },
        {
          $push: {
            resolution: {
              createdBy: req.user?.username,
              description: data.description,
            },
          },
        }
      );
    }
    const tickets = await TicketModel.find({
      targetedVulnerability: {
        $elemMatch: {
          cveId: data.cveId,
        },
      },
    });
    tickets.forEach(async (ticket) => {
      await ChangeHistoryModel.create({
        objectId: ticket._id,
        action: "update",
        timestamp: new Date(),
        account: req.user?._id,
        description: `${req.user?.username} added a resolution to ${data.cveId}`,
      });
    });
    return res.json(successResponse(null, "Resolution added successfully"));
  } catch (error) {
    return res.json(errorResponse(`Internal server error: ${error}`));
  }
}
export async function getResolution(req: Request, res: Response) {
  const { cveId } = req.query;
  try {
    const resolution = await ResolutionHistoryModel.find({ cveId });
    if (!resolution) {
      return res.json(errorResponse("Resolution not found"));
    }
    return res.json(
      successResponse(resolution, "Resolution fetched successfully")
    );
  } catch (error) {
    return res.json(errorResponse(`Internal server error: ${error}`));
  }
}
export async function approveResolution(req: Request, res: Response) {
  const {
    data: { resolutionId },
  } = req.body;
  try {
    await ResolutionHistoryModel.findOneAndUpdate(
      {
        resolution: {
          $elemMatch: {
            _id: resolutionId,
          },
        },
      },
      {
        $set: {
          "resolution.$.isApproved": true,
        },
      }
    );
    const resolution = await ResolutionHistoryModel.findOne({
      resolution: {
        $elemMatch: {
          _id: resolutionId,
        },
      },
    });
    const cveId = resolution?.cveId;
    const tickets = await TicketModel.find({
      targetedVulnerability: {
        $elemMatch: {
          cveId: cveId,
        },
      },
    });
    tickets.forEach(async (ticket) => {
      await ChangeHistoryModel.create({
        objectId: ticket._id,
        action: "update",
        timestamp: new Date(),
        account: req.user?._id,
        description: `${req.user?.username} approved a resolution of ${cveId}`,
      });
    });
    return res.json(successResponse(null, "Resolution approved successfully"));
  } catch (error) {
    return res.json(errorResponse(`Internal server error: ${error}`));
  }
}
